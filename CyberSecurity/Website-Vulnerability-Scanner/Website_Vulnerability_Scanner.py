import tkinter as tk
from tkinter import scrolledtext, messagebox
import threading
import requests
import socket
import urllib3
from bs4 import BeautifulSoup
import time
from concurrent.futures import ThreadPoolExecutor

# Ignore SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def scan_website():
    url = url_entry.get().strip()
    result_text.delete(1.0, tk.END)
    result_text.insert(tk.END, f"Scanning {url}...\n\n")
    threading.Thread(target=perform_scan, args=(url,), daemon=True).start()

def perform_scan(url):
    try:
        update_dashboard("Scanning started...")
        
        # Security Headers Check
        update_dashboard("=== Checking security headers ===")
        try:
            response = requests.get(url, verify=False)
            headers = response.headers
            security_headers = [
                "Content-Security-Policy", "X-Frame-Options", "X-XSS-Protection",
                "Strict-Transport-Security", "X-Content-Type-Options"
            ]
            missing_headers = []
            for header in security_headers:
                if header in headers:
                    update_dashboard(f"✔ {header}: {headers[header]}")
                else:
                    missing_headers.append(header)

            if missing_headers:
                update_dashboard("✘ Missing Security Headers: " + ", ".join(missing_headers) + 
                                 " - Consider adding these to enhance security as per OWASP guidelines.")
            else:
                update_dashboard("✔ All recommended security headers are present.")
        except requests.exceptions.RequestException as e:
            update_dashboard(f"[Error] Failed to retrieve headers: {e}")
        update_dashboard("=== Security headers check finished ===\n")

        # Enhanced Open Ports Scan
        update_dashboard("=== Initiating scan for open TCP ports (this may take a while) ===")
        ip = socket.gethostbyname(url.split("//")[-1].split("/")[0])  # Simplified IP extraction
        open_ports = []
        
        def handle_future(future, port):
            try:
                if future.result():
                    open_ports.append(port)
            except Exception as e:
                update_dashboard(f"[Error] Scanning port {port}: {e}")

        with ThreadPoolExecutor(max_workers=100) as executor:
            futures = {executor.submit(scan_port, ip, port): port for port in range(1, 1025)}
            for future in futures:
                handle_future(future, futures[future])

        if open_ports:
            for port in open_ports:
                update_dashboard(f"[!] Open TCP Port: {port} - Ensure to close unnecessary ports to reduce attack surface.")
        else:
            update_dashboard("✔ No open TCP ports found.")
        update_dashboard("=== Open TCP ports scan completed ===\n")

        # Enhanced UDP Ports Scan
        update_dashboard("=== Initiating scan for open UDP ports ===")
        open_udp_ports = []
        for port in range(1, 1025):
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.settimeout(1)
                if sock.sendto(b'', (ip, port)):
                    open_udp_ports.append(port)

        if open_udp_ports:
            for port in open_udp_ports:
                update_dashboard(f"[!] Open UDP Port: {port} - Consider implementing firewall rules to restrict access.")
        else:
            update_dashboard("✔ No open UDP ports found.")
        update_dashboard("=== Open UDP ports scan completed ===\n")

        # CMS Detection
        update_dashboard("=== Detecting Content Management Systems (CMS) ===")
        cms_signatures = {
            "WordPress": "/wp-login.php",
            "Joomla": "/administrator/",
            "Drupal": "/user/login",
            "Magento": "/admin/",
            "Shopify": "/admin/login",
            "Blogger": "/admin/login"
        }
        cms_detected = False
        for cms, path in cms_signatures.items():
            try:
                response = requests.get(f"{url}{path}", verify=False)
                if response.status_code == 200:
                    update_dashboard(f"[!] {cms} detected! Ensure to keep your CMS and plugins updated to mitigate vulnerabilities.")
                    cms_detected = True
                    break
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Could not check {cms}: {e}")
        if not cms_detected:
            update_dashboard("✔ No CMS detected.")
        update_dashboard("=== CMS detection finished ===\n")

        # SQL Injection Detection
        update_dashboard("=== Checking for SQL Injection vulnerabilities ===")
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' -- ",
            "' OR '1'='1' #",
            "' UNION SELECT NULL, username, password FROM users -- ",
            "'; DROP TABLE users; -- "
        ]
        sql_vulnerable = False
        for payload in sql_payloads:
            test_url = f"{url}?id={payload}"
            try:
                response = requests.get(test_url, verify=False)
                if "error" in response.text.lower() or "mysql" in response.text.lower() or "syntax" in response.text.lower():
                    update_dashboard("[!] Possible SQL Injection vulnerability detected! Ensure to use prepared statements and parameterized queries to mitigate this risk.")
                    sql_vulnerable = True
                    break
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Request failed for payload {payload}: {e}")
        if not sql_vulnerable:
            update_dashboard("✔ No SQL Injection vulnerabilities detected.")
        update_dashboard("=== SQL Injection check finished ===\n")

        # XSS Detection
        update_dashboard("=== Checking for XSS vulnerabilities ===")
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "<iframe src='javascript:alert(1)'>",
            "<body onload=alert('XSS')>"
        ]
        xss_vulnerable = False
        for payload in xss_payloads:
            test_url = f"{url}?q={payload}"
            try:
                response = requests.get(test_url, verify=False)
                if response.status_code == 200 and payload in response.text:
                    update_dashboard("[!] Possible XSS vulnerability detected! Implement input validation and output encoding to mitigate this risk.")
                    xss_vulnerable = True
                    break
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Request failed for payload {payload}: {e}")
        if not xss_vulnerable:
            update_dashboard("✔ No XSS vulnerabilities detected.")
        update_dashboard("=== XSS check finished ===\n")

        # API Check
        update_dashboard("=== Checking for API endpoints ===")
        api_paths = ["/api", "/api/v1", "/api/v2", "/api/users", "/api/products"]
        api_detected = False
        for path in api_paths:
            api_url = f"{url}{path}"
            try:
                response = requests.get(api_url, verify=False)
                if response.status_code == 200:
                    update_dashboard(f"[!] API endpoint detected: {api_url} - Ensure proper authentication and authorization are in place.")
                    api_detected = True
                elif response.status_code == 404:
                    update_dashboard(f"[INFO] API endpoint not found: {api_url}")
                else:
                    update_dashboard(f"[INFO] API endpoint returned status code {response.status_code}: {api_url}")
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Could not access {api_url}: {e}")
        if not api_detected:
            update_dashboard("✔ No API endpoints detected.")
        update_dashboard("=== API check finished ===\n")

        # Sensitive File/Directory Check
        update_dashboard("=== Checking for sensitive files and directories ===")
        sensitive_files = [
            "/robots.txt", "/.env", "/wp-config.php", "/.git/config", "/.htaccess",
            "/backup.zip", "/admin/config.php", "/config.php", "/database.sql",
            "/.DS_Store", "/web.config", "/phpinfo.php"
        ]
        sensitive_files_found = []
        for file_path in sensitive_files:
            try:
                response = requests.get(f"{url}{file_path}", verify=False)
                if response.status_code == 200:
                    sensitive_files_found.append(file_path)
                    update_dashboard(f"[!] Sensitive file/directory exposed: {file_path} - Restrict access to this file.")
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Could not access {file_path}: {e}")
        
        if not sensitive_files_found:
            update_dashboard("✔ No sensitive files or directories found.")
        else:
            update_dashboard(f"✔ Found {len(sensitive_files_found)} sensitive files/directories.")

        update_dashboard("=== Sensitive files and directories check finished ===\n")
        update_dashboard("=== Scan Complete! ===")
    except Exception as e:
        update_dashboard(f"[Error] {e}")

def scan_port(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex((ip, port))
    sock.close()
    return result == 0

def update_dashboard(message):
    result_text.insert(tk.END, message + "\n")
    result_text.yview(tk.END)
    root.update()

# GUI Setup
root = tk.Tk()
root.title("Website Vulnerability Scanner")
root.geometry("600x500")

tk.Label(root, text="Enter Website URL:").pack()
url_entry = tk.Entry(root, width=50)
url_entry.pack()

scan_button = tk.Button(root, text="Start Scan", command=scan_website)
scan_button.pack()

result_text = scrolledtext.ScrolledText(root, width=70, height=20)
result_text.pack()

root.mainloop()
