import tkinter as tk
from tkinter import scrolledtext, messagebox, filedialog
import threading
import requests
import socket
import urllib3
from bs4 import BeautifulSoup
import time
from concurrent.futures import ThreadPoolExecutor
import datetime
import os

# Ignore SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def scan_website():
    url = url_entry.get().strip()
    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL")
        return
    result_text.delete(1.0, tk.END)
    result_text.insert(tk.END, f"Scanning {url}...\n\n")
    threading.Thread(target=perform_scan, args=(url,), daemon=True).start()

def perform_scan(url):
    try:
        update_dashboard("Scanning started...")
        update_dashboard(f"Time: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        update_dashboard(f"Target URL: {url}\n")
        
        # Security Headers Check
        update_dashboard("=== Checking security headers ===")
        try:
            response = requests.get(url, verify=False)
            headers = response.headers
            security_headers = [
                "Content-Security-Policy", "X-Frame-Options", "X-XSS-Protection",
                "Strict-Transport-Security", "X-Content-Type-Options"
            ]
            missing_headers = []
            for header in security_headers:
                if header in headers:
                    update_dashboard(f"✔ {header}: {headers[header]}")
                else:
                    missing_headers.append(header)

            if missing_headers:
                update_dashboard("✘ Missing Security Headers: " + ", ".join(missing_headers) + 
                                 " - Consider adding these to enhance security as per OWASP guidelines.")
            else:
                update_dashboard("✔ All recommended security headers are present.")
        except requests.exceptions.RequestException as e:
            update_dashboard(f"[Error] Failed to retrieve headers: {e}")
        update_dashboard("=== Security headers check finished ===\n")

        # Enable the save and copy buttons since we have scan results
        enable_result_buttons()

        # Enhanced Open Ports Scan
        update_dashboard("=== Initiating scan for open TCP ports (this may take a while) ===")
        ip = socket.gethostbyname(url.split("//")[-1].split("/")[0])  # Simplified IP extraction
        open_ports = []
        
        def handle_future(future, port):
            try:
                if future.result():
                    open_ports.append(port)
            except Exception as e:
                update_dashboard(f"[Error] Scanning port {port}: {e}")

        with ThreadPoolExecutor(max_workers=100) as executor:
            futures = {executor.submit(scan_port, ip, port): port for port in range(1, 1025)}
            for future in futures:
                handle_future(future, futures[future])

        if open_ports:
            for port in open_ports:
                update_dashboard(f"[!] Open TCP Port: {port} - Ensure to close unnecessary ports to reduce attack surface.")
        else:
            update_dashboard("✔ No open TCP ports found.")
        update_dashboard("=== Open TCP ports scan completed ===\n")

        # Enhanced UDP Ports Scan
        update_dashboard("=== Initiating scan for open UDP ports ===")
        open_udp_ports = []
        for port in range(1, 1025):
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.settimeout(1)
                if sock.sendto(b'', (ip, port)):
                    open_udp_ports.append(port)

        if open_udp_ports:
            for port in open_udp_ports:
                update_dashboard(f"[!] Open UDP Port: {port} - Consider implementing firewall rules to restrict access.")
        else:
            update_dashboard("✔ No open UDP ports found.")
        update_dashboard("=== Open UDP ports scan completed ===\n")

        # CMS Detection
        update_dashboard("=== Detecting Content Management Systems (CMS) ===")
        cms_signatures = {
            "WordPress": "/wp-login.php",
            "Joomla": "/administrator/",
            "Drupal": "/user/login",
            "Magento": "/admin/",
            "Shopify": "/admin/login",
            "Blogger": "/admin/login"
        }
        cms_detected = False
        for cms, path in cms_signatures.items():
            try:
                response = requests.get(f"{url}{path}", verify=False)
                if response.status_code == 200:
                    update_dashboard(f"[!] {cms} detected! Ensure to keep your CMS and plugins updated to mitigate vulnerabilities.")
                    cms_detected = True
                    break
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Could not check {cms}: {e}")
        if not cms_detected:
            update_dashboard("✔ No CMS detected.")
        update_dashboard("=== CMS detection finished ===\n")

        # SQL Injection Detection
        update_dashboard("=== Checking for SQL Injection vulnerabilities ===")
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' -- ",
            "' OR '1'='1' #",
            "' UNION SELECT NULL, username, password FROM users -- ",
            "'; DROP TABLE users; -- "
        ]
        sql_vulnerable = False
        for payload in sql_payloads:
            test_url = f"{url}?id={payload}"
            try:
                response = requests.get(test_url, verify=False)
                if "error" in response.text.lower() or "mysql" in response.text.lower() or "syntax" in response.text.lower():
                    update_dashboard("[!] Possible SQL Injection vulnerability detected! Ensure to use prepared statements and parameterized queries to mitigate this risk.")
                    sql_vulnerable = True
                    break
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Request failed for payload {payload}: {e}")
        if not sql_vulnerable:
            update_dashboard("✔ No SQL Injection vulnerabilities detected.")
        update_dashboard("=== SQL Injection check finished ===\n")

        # XSS Detection
        update_dashboard("=== Checking for XSS vulnerabilities ===")
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "<iframe src='javascript:alert(1)'>",
            "<body onload=alert('XSS')>"
        ]
        xss_vulnerable = False
        for payload in xss_payloads:
            test_url = f"{url}?q={payload}"
            try:
                response = requests.get(test_url, verify=False)
                if response.status_code == 200 and payload in response.text:
                    update_dashboard("[!] Possible XSS vulnerability detected! Implement input validation and output encoding to mitigate this risk.")
                    xss_vulnerable = True
                    break
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Request failed for payload {payload}: {e}")
        if not xss_vulnerable:
            update_dashboard("✔ No XSS vulnerabilities detected.")
        update_dashboard("=== XSS check finished ===\n")

        # API Check
        update_dashboard("=== Checking for API endpoints ===")
        api_paths = ["/api", "/api/v1", "/api/v2", "/api/users", "/api/products"]
        api_detected = False
        for path in api_paths:
            api_url = f"{url}{path}"
            try:
                response = requests.get(api_url, verify=False)
                if response.status_code == 200:
                    update_dashboard(f"[!] API endpoint detected: {api_url} - Ensure proper authentication and authorization are in place.")
                    api_detected = True
                elif response.status_code == 404:
                    update_dashboard(f"[INFO] API endpoint not found: {api_url}")
                else:
                    update_dashboard(f"[INFO] API endpoint returned status code {response.status_code}: {api_url}")
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Could not access {api_url}: {e}")
        if not api_detected:
            update_dashboard("✔ No API endpoints detected.")
        update_dashboard("=== API check finished ===\n")

        # Sensitive File/Directory Check
        update_dashboard("=== Checking for sensitive files and directories ===")
        sensitive_files = [
            "/robots.txt", "/.env", "/wp-config.php", "/.git/config", "/.htaccess",
            "/backup.zip", "/admin/config.php", "/config.php", "/database.sql",
            "/.DS_Store", "/web.config", "/phpinfo.php"
        ]
        sensitive_files_found = []
        for file_path in sensitive_files:
            try:
                response = requests.get(f"{url}{file_path}", verify=False)
                if response.status_code == 200:
                    sensitive_files_found.append(file_path)
                    update_dashboard(f"[!] Sensitive file/directory exposed: {file_path} - Restrict access to this file.")
            except requests.exceptions.RequestException as e:
                update_dashboard(f"[Error] Could not access {file_path}: {e}")
        
        if not sensitive_files_found:
            update_dashboard("✔ No sensitive files or directories found.")
        else:
            update_dashboard(f"✔ Found {len(sensitive_files_found)} sensitive files/directories.")

        update_dashboard("=== Sensitive files and directories check finished ===\n")
        update_dashboard("=== Scan Complete! ===")
    except Exception as e:
        update_dashboard(f"[Error] {e}")

def scan_port(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex((ip, port))
    sock.close()
    return result == 0

def update_dashboard(message):
    result_text.insert(tk.END, message + "\n")
    result_text.yview(tk.END)
    root.update()

def save_to_file():
    domain = url_entry.get().strip().replace("https://", "").replace("http://", "").split("/")[0]
    filename = f"vulnerability_scan_{domain}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    file_path = filedialog.asksaveasfilename(
        defaultextension=".txt",
        initialfile=filename,
        filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
    )
    if file_path:
        try:
            # Using UTF-8 encoding with error handling
            with open(file_path, "w", encoding="utf-8", errors="replace") as f:
                report_content = result_text.get(1.0, tk.END)
                f.write(report_content)
            messagebox.showinfo("Success", f"Report saved to {file_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not save report: {e}")
            # Attempt fallback with ASCII only
            try:
                with open(file_path, "w", encoding="ascii", errors="ignore") as f:
                    report_content = result_text.get(1.0, tk.END)
                    f.write(report_content)
                messagebox.showinfo("Success", f"Report saved with limited character set to {file_path}")
            except Exception as fallback_error:
                messagebox.showerror("Critical Error", f"Failed to save even with fallback: {fallback_error}")

def copy_to_clipboard():
    root.clipboard_clear()
    root.clipboard_append(result_text.get(1.0, tk.END))
    messagebox.showinfo("Success", "Report copied to clipboard")

def enable_result_buttons():
    save_button.config(state=tk.NORMAL)
    copy_button.config(state=tk.NORMAL)

# GUI Setup
root = tk.Tk()
root.title("Website Vulnerability Scanner")
root.geometry("700x600")

# URL Entry Frame
url_frame = tk.Frame(root)
url_frame.pack(pady=10)

tk.Label(url_frame, text="Enter Website URL:").pack(side=tk.LEFT)
url_entry = tk.Entry(url_frame, width=50)
url_entry.pack(side=tk.LEFT, padx=5)
scan_button = tk.Button(url_frame, text="Start Scan", command=scan_website)
scan_button.pack(side=tk.LEFT)

# Results Text Area
result_text = scrolledtext.ScrolledText(root, width=80, height=30)
result_text.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

# Buttons Frame
button_frame = tk.Frame(root)
button_frame.pack(pady=10)

save_button = tk.Button(button_frame, text="Save Report", command=save_to_file, state=tk.DISABLED)
save_button.pack(side=tk.LEFT, padx=5)

copy_button = tk.Button(button_frame, text="Copy to Clipboard", command=copy_to_clipboard, state=tk.DISABLED)
copy_button.pack(side=tk.LEFT, padx=5)

root.mainloop()
